C51 COMPILER V8.05a   FIXEDPULSER                                                          08/09/2017 16:25:14 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE FIXEDPULSER
OBJECT MODULE PLACED IN .\fixedPulser.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\COMMON_HARDWARE\fixedPulser\fixedPulser.c LARGE WARNINGLEVEL
                    -(0) BROWSE DEBUG OBJECTEXTEND PRINT(.\fixedPulser.lst) TABS(2) OBJECT(.\fixedPulser.obj)

line level    source

   1          /************************************************************
   2          * ֯ƣ
   3          * ļ: K:\Ƭ\Ӵ\HARDWARE\COMMON_HARDWARE\FIXEDPULSER.C
   4          * :   ܳ
   5          * 汾:  1.0
   6          * :     2017/07/18
   7          * : ̶,ඨ巢PULSER_1ʹöʱ3 p04PULSER_2ʹöʱ4  p06
   8          * ʷ޸ļ¼:
   9          * <> <ʱ> <汾 > <>
  10          *  ܳ 7/25  1.1  ˶ʱĶʱʱ䣬ԭܲ2500hzɿԲ5000hz
  11          *  ܳ 7/27  1.2   ¶巢Ĳʽʹʱ·壬СԲ16hz
  12          ***********************************************************/
  13          
  14          #include "fixedPulser.h"
  15          #define PULSER_NUM  2 //Ҫʹöٸ巢ɲ·ͬƵʵ
  16          #define DEFAULT_PT  LOW //巢ʼλ
  17          
  18          #define OPEN_TIMER3_CLKOUT() T4T3M |= 1
  19          #define OPEN_TIMER4_CLKOUT() T4T3M |= (1 << 4)
  20          #define CLOSE_TIMER3_CLKOUT() T4T3M &=(~ 1)
  21          #define CLOSE_TIMER4_CLKOUT() T4T3M &=(~(1 << 4))
  22          
  23          
  24          //#define DEFAULT_PT  LOW //
  25          struct Pulser //巢йزݽṹ
  26          {
  27            u32 count;  //
  28            u16 Hz;     //Ƶ
  29            u8 state;   //巢ǰ״̬
  30          
  31          };
  32          
  33          static struct Pulser g_pulser[PULSER_NUM];  //巢Ϣ洢
  34          static u16 tmp = 0;//ʱҪʹõıдΪ˼жϵļӶʱ
  35          static bit timer2UseBit = 0;//ǷҪʹüڶʱͿɲƵʵı־λ
  36          static bit timer3UseBit = 0;//ǷҪʹüڶʱͿɲƵʵı־λ
  37          bool setPulse(u8 pulser_num, u16 Hz, u32 count)
  38          {
  39   1        u16 timerTmp = 0;
  40   1        u16 TIM_Value;
  41   1        g_pulser[pulser_num].Hz = Hz;
  42   1        g_pulser[pulser_num].count = count;
  43   1        if (pulser_num == PULSER_1)
  44   1        {
  45   2          if (Hz > 20)//20hzֱʹöʱֵ
  46   2          {
  47   3            //PrintString1("hz >20\r\n");
  48   3      
  49   3            TIM_Value = (65536UL - ((MAIN_Fosc / 12) / Hz / 2));
  50   3            timer2UseBit = 0;
  51   3            INT_CLKO |= 0x04; //ʱ
  52   3            TH2 = (u8)(TIM_Value >> 8);
  53   3            TL2 = (u8)TIM_Value;
  54   3      
C51 COMPILER V8.05a   FIXEDPULSER                                                          08/09/2017 16:25:14 PAGE 2   

  55   3          }
  56   2          else//С20hz
  57   2          {
  58   3            timer2UseBit = 1;
  59   3            //  CLOSE_TIMER2_CLKOUT();
  60   3          }
  61   2        }
  62   1        else
  63   1        {
  64   2          if (Hz > 20)
  65   2          {
  66   3            TIM_Value = (65536UL - ((MAIN_Fosc / 12) / Hz / 2));
  67   3            timer3UseBit = 0;
  68   3            T4T3M |= 1; //ʱ
  69   3            TH3 = (u8)(TIM_Value >> 8);
  70   3            TL3 = (u8)TIM_Value;
  71   3      
  72   3          }
  73   2          else
  74   2          {
  75   3            timer3UseBit = 1;
  76   3          }
  77   2        }
  78   1      
  79   1        return 1;
  80   1      }
  81          bool openPulser(u8 pulser_num)
  82          {
  83   1      
  84   1        g_pulser[pulser_num].state = ON;
  85   1      
  86   1        if (pulser_num == PULSER_1) //pulser2
  87   1        {
  88   2          Timer2_Run();
  89   2      
  90   2        }
  91   1        else   //pulser1
  92   1        {
  93   2          Timer3_Run();
  94   2        }
  95   1      
  96   1        return OK;
  97   1      }
  98          bool closePulser(u8 pulser_num)
  99          {
 100   1        if (pulser_num == PULSER_1)//pulser2
 101   1        {
 102   2          Timer2_Stop();
 103   2      
 104   2      
 105   2        }
 106   1        else //pulser1
 107   1        {
 108   2          Timer3_Stop();
 109   2      
 110   2        }
 111   1        g_pulser[pulser_num].state = OFF;
 112   1        return OK;
 113   1      
 114   1      }
 115          bool getPulserState(u8 pulser_num)
 116          {
C51 COMPILER V8.05a   FIXEDPULSER                                                          08/09/2017 16:25:14 PAGE 3   

 117   1      
 118   1        return g_pulser[pulser_num].state;
 119   1      
 120   1      }
 121          void PulserInit(void)//ʼ
 122          {
 123   1        //PULSER_1 ʹP30 PULSER_2 ʹP04
 124   1      
 125   1        GPIO_InitTypeDef    GPIO_InitStructure;     //ṹ
 126   1        GPIO_InitStructure.Mode = GPIO_PullUp;       //ָIOʽ,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,
             -GPIO_OUT_PP
 127   1        GPIO_InitStructure.Pin = GPIO_Pin_0;    //ָҪʼIO, GPIO_Pin_0 ~ GPIO_Pin_7, !!!!!!!GPIO
             -ʹðλ߼֮ǰΪ
 128   1        GPIO_Inilize(GPIO_P3, &GPIO_InitStructure);  //ʼ
 129   1        GPIO_InitStructure.Pin = GPIO_Pin_4;    //ָҪʼIO, GPIO_Pin_0 ~ GPIO_Pin_7, !!!!!!!GPIO
             -ʹðλ߼֮ǰΪ
 130   1        GPIO_Inilize(GPIO_P0, &GPIO_InitStructure);  //ʼ
 131   1        g_pulser[PULSER_1].state = OFF;
 132   1        g_pulser[PULSER_2].state = OFF;     
 133   1        //  P30=0;
 134   1        //P04=0;  
 135   1      
 136   1      
 137   1      
 138   1      #ifdef DEBUG
                //PrintString1("two pulser was initialized\r\n");
              #endif
 141   1      }
 142          
 143          
 144          /***************Ϊ˽кģ********************************/
 145          
 146          /********************* Timer3жϺڲָ************************/
 147          //200usһжϣ
 148          static u16 pulser1Tmp = 0;
 149          static u16 count1Tmp = 0;
 150          //static void Pulser_1Int(void) interrupt TIMER2_VECTOR   //2.5msһж
 151          //{
 152          //  //PrintString1("into timer inte\n");
 153          ////  if (timer2UseBit == 1)//õƵС20hzʹüۼӵİ취
 154          ////  {
 155          ////    if (++pulser1Tmp >= tmp)
 156          
 157          ////    {
 158          ////      //  PrintString1("p15 state changed\n");
 159          
 160          ////      pulser1Tmp = 0;
 161          ////      if (count1Tmp++ <= g_pulser[PULSER_1].count)
 162          ////      {
 163          ////        P30 = ~P30;
 164          
 165          ////        //  PrintString1("p15 state is changed\n");
 166          ////      }
 167          ////      else
 168          ////      {
 169          ////        closePulser(PULSER_1);
 170          ////        count1Tmp = 0;
 171          
 172          ////      }
 173          ////    }
 174          ////  }
 175          ////  else//Ƶʴ20ֱø
C51 COMPILER V8.05a   FIXEDPULSER                                                          08/09/2017 16:25:14 PAGE 4   

 176          //  {
 177          //    if (++count1Tmp >= g_pulser[PULSER_1].count*2)
 178          //    {
 179          //      count1Tmp = 0;
 180          //      closePulser(PULSER_1);
 181          //    }
 182          //  }
 183          static void Pulser_1Int(void) interrupt TIMER2_VECTOR   //2.5msһж
 184          {
 185   1        if ((++pulser1Tmp) >= 2 * g_pulser[PULSER_1].count)
 186   1        {
 187   2          closePulser(PULSER_1);
 188   2          pulser1Tmp = 0;
 189   2        }
 190   1      
 191   1      }
 192          static u16 pulser2Tmp = 0;
 193          static u16 count2Tmp = 0;
 194          
 195          static void Pulser_2Int(void) interrupt TIMER3_VECTOR   //2.5msһж
 196          {
 197   1        if ((++pulser2Tmp) >= 2 * g_pulser[PULSER_2].count)
 198   1        {
 199   2          closePulser(PULSER_2);
 200   2          pulser2Tmp = 0;
 201   2        }
 202   1      
 203   1      }
 204          
 205          
 206          //static u32 g_PWM_7tmp = 0;//
 207          ////жִг¼ĸʱرշ
 208          //static void PWM_Routine(void) interrupt 22   
 209          //{
 210          
 211          //  if (PWMIF ^ 5 == 1)//PWM_7ڶתж
 212          //  {
 213          
 214          //    PWMIF &= (~(1 << 5));  //־λ
 215          //  //  PrintString1(" pwm7 count++\n");
 216          
 217          //    if (g_PWM_7tmp++ >= g_pulser[PULSER_1].count)
 218          //    {
 219          //      //      PrintString1("pwm7 temp >= count\n");
 220          //      g_PWM_7tmp = 0;
 221          //      closePulser(PULSER_1); //ָ͹ر巢
 222          
 223          //    }
 224          
 225          //  }
 226          //  //ѡʹöʱģһ·巢
 227          //  //  if (PWMIF ^ 4 == 1)//PWM_6
 228          //  //  {
 229          //  //    PWMIF &= (~(1 << 4));  //־λ
 230          //  ////      PrintString1("pwm6 count++\n");
 231          //  //    if (g_PWM_6tmp++ >= g_pulser[PULSER_2].count)
 232          //  //    {
 233          //  //      //          PrintString1(" pwm6 temp >= count\n");
 234          //  //      g_PWM_6tmp = 0;
 235          //  //      closePulser(PULSER_2);
 236          //  //      close_PWM_ALL();
 237          //  //    }
C51 COMPILER V8.05a   FIXEDPULSER                                                          08/09/2017 16:25:14 PAGE 5   

 238          //  //
 239          //  //  }
 240          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    604    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     24      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
